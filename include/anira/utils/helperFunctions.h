#ifndef ANIRA_HELPERFUNCTIONS_H
#define ANIRA_HELPERFUNCTIONS_H

#include <vector>
#include <algorithm>
#include <stdexcept>
#include "Buffer.h"
#include "RingBuffer.h"

namespace anira {

/* ============================================================ *
 * ===================== Helper functions ===================== *
 * ============================================================ */

/**
 * @brief Generates a random audio sample in the range [-1.0, 1.0]
 * 
 * Creates a random floating-point value suitable for audio processing,
 * with values uniformly distributed between -1.0 and 1.0. This function
 * is commonly used for generating test audio data and noise.
 * 
 * @return Random sample value in the range [-1.0, 1.0]
 * 
 * @note This function uses std::rand() which should be seeded with srand()
 *       before use for proper randomization. For real-time applications,
 *       consider using faster random number generators.
 */
static float random_sample () {
    return -1.f + (float) (std::rand()) / (((float) RAND_MAX/2.f));
}

/**
 * @brief Calculates a specific percentile value from a dataset
 * 
 * Computes the specified percentile from a vector of double values using
 * linear interpolation when necessary. The function sorts the input data
 * and calculates the percentile using standard statistical methods.
 * 
 * This function is useful for statistical analysis of performance metrics,
 * latency measurements, and other quantitative data analysis tasks.
 * 
 * @param v Vector of double values to calculate percentile from
 * @param percentile Percentile to calculate (0.0 to 1.0, e.g., 0.99 for 99th percentile)
 * @return The calculated percentile value
 * 
 * @throws std::invalid_argument If the input vector is empty
 * 
 * @note The function creates a copy of the input vector for sorting,
 *       which may have memory implications for large datasets.
 */
static double calculate_percentile(const std::vector<double>& v, double percentile) {
    // Make sure the data is not empty
    if (v.empty()) {
        throw std::invalid_argument("Input vector is empty.");
    }

    // Sort the data in ascending order
    std::vector<double> sorted_data = v;
    std::sort(sorted_data.begin(), sorted_data.end());

    // Calculate the index for the 99th percentile
    size_t n = sorted_data.size();
    size_t percentile_index = (size_t) (percentile * (n - 1));

    // Check if the index is an integer
    if (percentile_index == static_cast<size_t>(percentile_index)) {
        // The index is an integer, return the value at that index
        return sorted_data[static_cast<size_t>(percentile_index)];
    } else {
        // Interpolate between the two nearest values
        size_t lower_index = static_cast<size_t>(percentile_index);
        size_t upper_index = lower_index + 1;
        double fraction = percentile_index - lower_index;
        return (1.0 - fraction) * sorted_data[lower_index] + fraction * sorted_data[upper_index];
    }
}

/**
 * @brief Fills a float buffer with random audio samples
 * 
 * Populates all samples in the first channel of the provided buffer with
 * random values generated by random_sample(). This function is primarily
 * used for testing and benchmarking purposes to create realistic audio data.
 * 
 * @param buffer Reference to the BufferF to fill with random samples
 */
static void fill_buffer(BufferF &buffer){
    for (size_t i = 0; i < buffer.get_num_channels(); i++){
        for (size_t j = 0; j < buffer.get_num_samples(); j++){
            float new_val = random_sample();
            buffer.set_sample(i, j, new_val);
        }
    }
}


/**
 * @brief Transfers all samples from a buffer to a ring buffer
 * 
 * Sequentially pushes all samples from the first channel of the source buffer
 * into the first channel of the destination ring buffer. This function is useful
 * for feeding audio data into circular buffers for streaming processing.
 * 
 * The operation maintains the temporal order of samples and respects the
 * ring buffer's circular nature with automatic position wrapping.
 * 
 * @param buffer Const reference to the source BufferF to read samples from
 * @param ringbuffer Reference to the destination RingBuffer to write samples to
 */
static void push_buffer_to_ringbuffer(BufferF const &buffer, RingBuffer &ringbuffer){
    if (buffer.get_num_channels() == 0 || buffer.get_num_samples() == 0) {
        throw std::invalid_argument("Buffer is empty, cannot push to ring buffer.");
    }
    if (ringbuffer.get_num_channels() == 0 || ringbuffer.get_num_samples() == 0) {
        throw std::invalid_argument("Ring buffer is not initialized, cannot push samples.");
    }
    for (size_t i = 0; i < buffer.get_num_channels(); i++){
        for (size_t j = 0; j < buffer.get_num_samples(); j++){
            ringbuffer.push_sample(i, buffer.get_sample(i, j));
        }
    }
}


/**
 * @brief Lambda function to calculate the minimum value in a dataset
 * 
 * A constant lambda expression that finds and returns the smallest value
 * in a vector of double values. This function uses std::min_element for
 * efficient minimum value computation.
 * 
 * @param v Vector of double values to find the minimum from
 * @return The minimum value in the vector
 * 
 * @note This is a lambda function stored as a const auto variable for
 *       convenient reuse throughout the codebase.
 */
const auto calculate_min = [](const std::vector<double>& v) -> double {
    return *(std::min_element(std::begin(v), std::end(v)));
};

/**
 * @brief Lambda function to calculate the maximum value in a dataset
 * 
 * A constant lambda expression that finds and returns the largest value
 * in a vector of double values. This function uses std::max_element for
 * efficient maximum value computation.
 * 
 * @param v Vector of double values to find the maximum from
 * @return The maximum value in the vector
 * 
 * @note This is a lambda function stored as a const auto variable for
 *       convenient reuse throughout the codebase.
 */
const auto calculate_max = [](const std::vector<double>& v) -> double {
    return *(std::max_element(std::begin(v), std::end(v)));
};

} // namespace anira

#endif // ANIRA_HELPERFUNCTIONS_H